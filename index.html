<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <!-- ğŸ“± æ‰‹æœºç«¯æ ¸å¿ƒè®¾ç½®ï¼šç¦æ­¢ç¼©æ”¾ï¼Œå¼ºåˆ¶å…¨å± -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>BYKUS 019 - Final</title>
  <style>
    /* å…¨å±é»‘åº•æ— æ»šåŠ¨æ¡ */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #141E23;
      font-family: sans-serif;
    }
    /* åŠ è½½æç¤ºæ–‡å­— */
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 14px;
      pointer-events: none;
    }
    /* ä¸Šä¼ æŒ‰é’®æ ·å¼ä¼˜åŒ– */
    input[type="file"] {
      position: absolute;
      top: 15px;
      left: 15px;
      z-index: 100;
      opacity: 0.8;
      transform: scale(1.2); /* æ”¾å¤§ä¸€ç‚¹æ–¹ä¾¿æ‰‹æŒ‡æŒ‰ */
      transform-origin: top left;
    }
  </style>
  <!-- å¼•å…¥ p5.js -->
  <script src="https://cdn.jsdelivr.net/npm/p5@1.9.0/lib/p5.min.js"></script>
</head>
<body>

<div id="loading">èµ„æºåŠ è½½ä¸­...</div>

<script>
/* 
   --- p5.js ä»£ç  (åŸºäºä½ çš„æä¾›è¿›è¡Œäº†æ ¼å¼ä¿®å¤) --- 
   è®¾å®š: é€Ÿåº¦ 2.0, æœ€å¤§é•¿åº¦ 10, èƒŒæ™¯å±…ä¸­
*/

let snake;
let bubbles = [];
let leaves = [];
let bgImage = null;
let inputButton;

// --- ğŸ”§ é…ç½®åŒºåŸŸ ---

let baseString = "BYKUS ";
let bubbleText = "019 BUBBLE GREEN ";

// é¢œè‰²é…ç½®
let snakeColorsHex = [
  '#E2ECEB',
  '#A7BB86',
  '#89A751',
  '#7FAA8E',
  '#C8D8D7'
];

// âœ¨ ä½ ä»£ç ä¸­çš„è®¾ç½®ï¼šé€Ÿåº¦å‡æ…¢
let snakeSpeed = 2.0;
let turnSpeed = 0.08;

function setup() {
  createCanvas(windowWidth, windowHeight);
  textAlign(CENTER, CENTER);

  // éšè—åŠ è½½æ–‡å­—
  let loadingDiv = select('#loading');
  if(loadingDiv) loadingDiv.style('display', 'none');

  inputButton = createFileInput(handleFile);
  inputButton.position(20, 20);
  inputButton.style('color', 'white');

  snake = new Snake(width / 2, height / 2);

  for (let i = 0; i < 8; i++) {
    bubbles.push(new Bubble());
  }
}

function handleFile(file) {
  if (file.type === 'image') {
    bgImage = loadImage(file.data);
  } else {
    bgImage = null;
  }
}

function draw() {
  drawBackground();

  // 1. æ°”æ³¡é€»è¾‘
  for (let i = bubbles.length - 1; i >= 0; i--) {
    let b = bubbles[i];
    b.update();
    b.display();

    // ç¢°æ’æ£€æµ‹
    if (snake.eats(b)) {
      // åˆ¤æ–­æ˜¯å¦è§¦å‘å¤§çˆ†ç‚¸
      let isBigBang = (snake.units >= snake.maxUnits);
      
      createExplosion(b.pos.x, b.pos.y, isBigBang);
      snake.grow();
      
      bubbles.splice(i, 1);
      bubbles.push(new Bubble());
    }
  }

  // 2. çƒŸèŠ±ç²’å­é€»è¾‘
  for (let i = leaves.length - 1; i >= 0; i--) {
    let l = leaves[i];
    l.update();
    l.display();
    if (l.isDead()) {
      leaves.splice(i, 1);
    }
  }

  // 3. è›‡é€»è¾‘
  snake.update();
  snake.display();

  if (!bgImage) {
    fill(255, 150);
    noStroke();
    textSize(14);
    text("â†– ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡", 100, 55);
  }
}

// âœ¨ ä¿®å¤ï¼šèƒŒæ™¯å±…ä¸­é€»è¾‘ (Cover æ¨¡å¼)
function drawBackground() {
  if (bgImage) {
    push();
    imageMode(CENTER);
    let scaleX = width / bgImage.width;
    let scaleY = height / bgImage.height;
    let scale = max(scaleX, scaleY); // ç¡®ä¿é“ºæ»¡
    image(bgImage, width / 2, height / 2, bgImage.width * scale, bgImage.height * scale);
    pop();
  } else {
    background(20, 30, 35);
  }
}

// âœ¨ çˆ†ç‚¸å‡½æ•°æ”¯æŒ "Big Mode"
function createExplosion(x, y, isBig) {
  let count = isBig ? 150 : 50; // å¦‚æœæ˜¯å¤§çƒŸèŠ±ï¼Œç²’å­å¤š3å€
  for (let j = 0; j < count; j++) {
    leaves.push(new Leaf(x, y, isBig));
  }
}

// --- ğŸ“± æ‰‹æœºé˜²æ­¢æ»šåŠ¨ ---
function touchMoved() {
  return false;
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  inputButton.position(20, 20);
}

// --- ğŸ è›‡ç±» ---
class Snake {
  constructor(x, y) {
    this.pos = createVector(x, y);
    this.vel = createVector(1, 0);
    this.angle = 0;
    this.history = [];
    this.units = 1;
    // âœ¨ ä½ ä»£ç ä¸­çš„è®¾ç½®ï¼šé•¿åº¦ 10
    this.maxUnits = 10;
    this.charSpacing = 12;
    this.colors = snakeColorsHex.map(hex => color(hex));
  }

  getFullString() {
    let s = "";
    for (let i = 0; i < this.units; i++) {
      s += baseString;
    }
    return s;
  }

  update() {
    let closest = null;
    let recordDist = Infinity;

    for (let b of bubbles) {
      let d = dist(this.pos.x, this.pos.y, b.pos.x, b.pos.y);
      if (d < recordDist) {
        recordDist = d;
        closest = b;
      }
    }

    // æ‰‹æœºä¼˜åŒ–ï¼šå¦‚æœæ²¡æœ‰æœ€è¿‘æ°”æ³¡ï¼Œä¸”æ²¡æœ‰è§¦æ‘¸ï¼Œå°±åœ¨é¼ æ ‡ä½ç½®(æˆ–é»˜è®¤ä½ç½®)
    let targetX = mouseX;
    let targetY = mouseY;
    if (mouseX === 0 && mouseY === 0) {
        targetX = width/2;
        targetY = height/2;
    }

    let targetPos = closest ? closest.pos : createVector(targetX, targetY);
    let desiredAngle = atan2(targetPos.y - this.pos.y, targetPos.x - this.pos.x);

    let diff = desiredAngle - this.angle;
    if (diff > PI) diff -= TWO_PI;
    if (diff < -PI) diff += TWO_PI;
    this.angle += diff * turnSpeed;

    this.vel = p5.Vector.fromAngle(this.angle);
    this.vel.mult(snakeSpeed);
    this.pos.add(this.vel);

    this.history.unshift(this.pos.copy());

    let fullStr = this.getFullString();
    let maxHistory = fullStr.length * (this.charSpacing / snakeSpeed * 1.5) + 50;

    if (this.history.length > maxHistory) {
      this.history.pop();
    }

    this.checkEdges();
  }

  grow() {
    this.units++;
    // é•¿åº¦é‡ç½®é€»è¾‘
    if (this.units > this.maxUnits) {
      this.units = 1;
    }
  }

  checkEdges() {
    if (this.pos.x > width) this.pos.x = 0;
    if (this.pos.x < 0) this.pos.x = width;
    if (this.pos.y > height) this.pos.y = 0;
    if (this.pos.y < 0) this.pos.y = height;

    if (this.history.length > 0) {
        if (dist(this.pos.x, this.pos.y, this.history[0].x, this.history[0].y) > snakeSpeed * 2) {
          this.history = [];
          this.history.push(this.pos.copy());
        }
    }
  }

  eats(bubble) {
    return dist(this.pos.x, this.pos.y, bubble.pos.x, bubble.pos.y) < (bubble.r + 10);
  }

  getGradientColor(t) {
    let numColors = this.colors.length;
    let scaledT = t * (numColors - 1);
    let index = floor(scaledT);
    let amt = scaledT - index;
    if (index >= numColors - 1) return this.colors[numColors - 1];
    return lerpColor(this.colors[index], this.colors[index + 1], amt);
  }

  display() {
    noStroke();
    textStyle(BOLD);
    let fullStr = this.getFullString();

    for (let i = 0; i < fullStr.length; i++) {
      let pathIndex = floor(i * (this.charSpacing / snakeSpeed));

      if (pathIndex < this.history.length) {
        let p = this.history[pathIndex];
        let progress = map(i, 0, fullStr.length, 0, 1);
        let c = this.getGradientColor(progress);
        fill(c);

        let size = map(i, 0, fullStr.length, 28, 14);
        textSize(size);

        push();
        translate(p.x, p.y);
        if (pathIndex + 1 < this.history.length) {
          let nextP = this.history[pathIndex + 1];
          let angle = atan2(p.y - nextP.y, p.x - nextP.x);
          rotate(angle + PI);
        }
        text(fullStr.charAt(i), 0, 0);
        pop();
      }
    }
  }
}

// --- ğŸ«§ æ–‡å­—æ°”æ³¡ ---
class Bubble {
  constructor() {
    this.pos = createVector(random(width), random(height));
    this.r = random(35, 50);
    this.noiseOffset = random(1000);
    this.rotation = random(TWO_PI);
    this.rotSpeed = random(-0.01, 0.01);
  }

  update() {
    this.pos.x += map(noise(this.noiseOffset), 0, 1, -1, 1);
    this.pos.y += map(noise(this.noiseOffset + 1000), 0, 1, -1, 1);
    this.noiseOffset += 0.005;
    this.rotation += this.rotSpeed;

    if (this.pos.x < -50) this.pos.x = width + 50;
    if (this.pos.x > width + 50) this.pos.x = -50;
    if (this.pos.y < -50) this.pos.y = height + 50;
    if (this.pos.y > height + 50) this.pos.y = -50;
  }

  display() {
    push();
    translate(this.pos.x, this.pos.y);
    rotate(this.rotation);
    noStroke();
    fill(255, 10);
    ellipse(0, 0, this.r * 2);

    let str = bubbleText;
    let anglePerChar = TWO_PI / str.length;

    fill(255);
    textSize(10);

    for (let i = 0; i < str.length; i++) {
      let char = str.charAt(i);
      push();
      rotate(i * anglePerChar);
      translate(0, -this.r);
      text(char, 0, 0);
      pop();
    }

    fill(255, 180);
    rotate(-this.rotation - QUARTER_PI);
    ellipse(0, -this.r * 0.6, this.r * 0.4, this.r * 0.25);
    pop();
  }
}

// --- ğŸ‚ çƒŸèŠ±å¶å­ ---
class Leaf {
  constructor(x, y, isBig) {
    this.pos = createVector(x, y);
    // åŒºåˆ†çˆ†ç‚¸ç±»å‹
    if (isBig) {
      this.vel = p5.Vector.random2D().mult(random(3, 15));
      this.decay = 0.4;
    } else {
      this.vel = p5.Vector.random2D().mult(random(5, 12));
      this.decay = 1.5;
    }
    this.lifespan = 255;
    this.color = color(random(snakeColorsHex));
    this.size = random(4, 8);
    this.drag = 0.96;
  }

  update() {
    this.vel.mult(this.drag);
    this.pos.add(this.vel);
    this.pos.y += 0.5;
    this.lifespan -= this.decay;
  }

  display() {
    noStroke();
    let c = this.color;
    fill(red(c), green(c), blue(c), this.lifespan);
    ellipse(this.pos.x, this.pos.y, this.size);
  }

  isDead() {
    return this.lifespan < 0;
  }
}
</script>
</body>
</html>
